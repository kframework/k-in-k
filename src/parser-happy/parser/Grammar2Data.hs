{-# OPTIONS  #-}


-- parser (data) produced by Happy (GLR) Version 1.19.9

module Grammar2Data where



import Data.Char
import qualified Data.Map as Map
import qualified Data.Array as Happy_Data_Array
import qualified Data.Bits as Bits
import Control.Applicative(Applicative(..))
import Control.Monad (ap)



{-# LINE 1 "templates/GLR_Base.hs" #-}
{-# LINE 1 "templates/GLR_Base.hs" #-}
{-# LINE 1 "<built-in>" #-}
{-# LINE 1 "<command-line>" #-}







# 1 "/usr/include/stdc-predef.h" 1 3 4

# 17 "/usr/include/stdc-predef.h" 3 4











































{-# LINE 7 "<command-line>" #-}
{-# LINE 1 "/home/mattox/.stack/programs/x86_64-linux/ghc-tinfo6-8.6.3/lib/ghc-8.6.3/include/ghcversion.h" #-}















{-# LINE 7 "<command-line>" #-}
{-# LINE 1 "/tmp/ghc14920_0/ghc_2.h" #-}
































































































































































































{-# LINE 7 "<command-line>" #-}
{-# LINE 1 "templates/GLR_Base.hs" #-}
{- GLR_Base.lhs
   Id: GLR_Base.lhs,v 1.4 2004/12/04 15:01:37 paulcc Exp 
-}

-- Basic defs required for compiling the data portion of the parser

-- We're creating Int-indexed graphs

type ForestId  = (Int,Int,GSymbol)


-- Actions for the GLR machine

data GLRAction = Shift Int [Reduction]
               | Reduce [Reduction]
               | Accept
               | Error

---
-- A Reduction (s,n,f) removes the top n node-ids, creates a new branch from these
-- and labels the branch with the given symbol s. Additionally, the branch may
-- hold some semantic value.

type Reduction = (GSymbol,Int, [ForestId] -> Branch)


---
-- A Branch holds the semantic result plus node ids of children

data Branch
 = Branch {b_sem :: GSem, b_nodes :: [ForestId]}
   deriving Show

instance Eq Branch where
        b1 == b2 = b_nodes b1 == b_nodes b2



-------------------------------------------------------------------------------
-- Utilities for decoding

---
-- Tree decode unpacks the forest into a list of results
--  - this is ok for small examples, but inefficient for very large examples
--  - the data file contains further instances
--  - see documentation for further information
--  - "Decode_Result" is a synonym used to insert the monad type constr (or not)

class TreeDecode a where
        decode_b :: (ForestId -> [Branch]) -> Branch -> [Decode_Result a]

decode :: TreeDecode a => (ForestId -> [Branch]) -> ForestId -> [Decode_Result a]
decode f i@(_,_,HappyTok t)
  = decode_b f (Branch (SemTok t) [])
decode f i
  = [ d | b <- f i, d <- decode_b f b ]

---- generated by Happy, since it means expansion of synonym (not ok in H-98)
--instance TreeDecode UserDefTok where
--      decode_b f (Branch (SemTok t) []) = [happy_return t]

---
-- this is used to multiply the ambiguous possibilities from children

--cross_fn :: [a -> b] -> [a] -> [b]
--actual type will depend on monad in use.
--happy_ap defined by parser generator
cross_fn fs as = [ f `happy_ap` a | f <- fs, a <- as]

---
-- Label decoding unpacks from the Semantic wrapper type
--  - this allows arbitrary values (within the limits of the compiler settings)
--    to be recovered from nodes in the tree.
--  - again, more instances are written in the data file
--  - see documentation for further information

class LabelDecode a where
        unpack :: GSem -> a

---- generated by Happy, since it means expansion of synonym (not ok in H-98)
--instance LabelDecode UserDefTok where
--      unpack (SemTok t) = t




{-# LINE 373 "parser/Grammar2Data.hs"#-}

parseError :: [Token] -> a
parseError x = error ("Parse error: " ++ show x)


data Token = TokenId String
           | TokenPlus
           | TokenPeriod
           | Token_s
           | TokenLeftParen
           | TokenRightParen
   deriving (Eq,Ord,Show)


lexId [] = ("",[])
lexId (c:xx) | isAlpha c =
  let (result,rest) = span isAlphaNum xx
   in (c:result, rest)

eatws (c:xs) | isSpace c = eatws xs
eatws xx = xx

lexer :: String -> [Token]
lexer [] = []
lexer (c:xs)  | isSpace c = lexer xs
lexer ('+':xs) = TokenPlus: lexer xs
lexer ('.':xs) = TokenPeriod: lexer xs
lexer ('(':xs) = TokenLeftParen: lexer xs
lexer (')':xs) = TokenRightParen: lexer xs

lexer xx = case lexId xx of
    ("",xs) -> [] -- handles eof
    ("s",xs) -> Token_s : lexer (eatws xs)
    ("END",xs) -> [] -- handles eof
    (s,xs) -> TokenId s : lexer xs

test G_Grm = "Grm"

blookup fid m = let Just x = Map.lookup fid m in fmap b_nodes x

output [[b1@(_,_,G_Nat),b2@(_,_,HappyTok TokenPlus),b3@(_,_,G_Nat)]] m =
    "plus(" ++ output (blookup b1 m) m ++ "," ++ output (blookup b3 m) m++ ")"

output [[b1@(_,_,HappyTok Token_s),b2@(_,_,HappyTok TokenLeftParen),b3@(_,_,G_Nat),b4@(_,_,HappyTok TokenRightParen)]] m =
    "succ(" ++ output (blookup b3 m) m++ ")"

output [[b1@(_,_,HappyTok TokenPeriod)]] m =
    "zero"

output [[b1@(_,_,G_Foo),b2@(_,_,HappyTok TokenPlus),b3@(_,_,G_Foo)]] m =
    "fooplus(" ++ output (blookup b1 m) m ++ "," ++ output (blookup b3 m) m++ ")"

output [[b1@(_,_,HappyTok Token_s),b2@(_,_,HappyTok TokenLeftParen),b3@(_,_,G_Foo),b4@(_,_,HappyTok TokenRightParen)]] m =
    "foosucc(" ++ output (blookup b3 m) m++ ")"

output [[b1@(_,_,HappyTok TokenPeriod)]] m =
    "foozero"

output (x:y:ys) m = "amb(" ++ output [x] m ++ "," ++ output (y:ys) m ++ ")"
output x m = error $ "Unrecognized productions: " ++ show x

{-# LINE 435 "parser/Grammar2Data.hs"#-}

data GSymbol = HappyEOF | HappyTok {-!Int-} (Token) | G_Grm 
 | G_Nat 
 | G_Foo 
   deriving (Show,Eq,Ord)

data GSem
 = NoSem
 | SemTok (Token) | Sem_0 (()) 
   deriving (Show)


semfn_0_0 ns@(happy_rest) =  Branch (Sem_0 ()) ns


type Decode_Result a = a
happy_ap = ($)
happy_return = id
instance LabelDecode (()) where 
  unpack (Sem_0 s) = s


type UserDefTok = Token
instance TreeDecode (Token) where
  decode_b f (Branch (SemTok t) []) = [happy_return t]
instance LabelDecode (Token) where
  unpack (SemTok t) = t


action 0 ( HappyTok (TokenPeriod) ) = Shift 3 []
action 0 ( HappyTok (Token_s) ) = Shift 4 []
action 1 ( HappyTok (TokenPeriod) ) = Shift 3 []
action 1 ( HappyTok (Token_s) ) = Shift 4 []
action 2 ( HappyTok (TokenPlus) ) = Shift 7 []
action 2 ( HappyEOF ) = Reduce [red_1]
action 3 ( HappyTok (TokenPlus) ) = Reduce [red_7]
action 3 ( HappyTok (TokenRightParen) ) = Reduce [red_7]
action 3 ( HappyEOF ) = Reduce [red_7]
action 4 ( HappyTok (TokenLeftParen) ) = Shift 6 []
action 5 ( HappyEOF ) = Accept
action 6 ( HappyTok (TokenPeriod) ) = Shift 3 []
action 6 ( HappyTok (Token_s) ) = Shift 4 []
action 7 ( HappyTok (TokenPeriod) ) = Shift 3 []
action 7 ( HappyTok (Token_s) ) = Shift 4 []
action 8 ( HappyTok (TokenPlus) ) = Shift 7 [red_5]
action 8 ( HappyTok (TokenRightParen) ) = Reduce [red_5]
action 8 ( HappyEOF ) = Reduce [red_5]
action 9 ( HappyTok (TokenPlus) ) = Shift 7 []
action 9 ( HappyTok (TokenRightParen) ) = Shift 10 []
action 10 ( HappyTok (TokenPlus) ) = Reduce [red_6]
action 10 ( HappyTok (TokenRightParen) ) = Reduce [red_6]
action 10 ( HappyEOF ) = Reduce [red_6]
action _ _ = Error
red_1 = (G_Grm,1 :: Int,semfn_0_0)
red_2 = (G_Nat,3 :: Int,semfn_0_0)
red_3 = (G_Nat,4 :: Int,semfn_0_0)
red_4 = (G_Nat,1 :: Int,semfn_0_0)
red_5 = (G_Foo,3 :: Int,semfn_0_0)
red_6 = (G_Foo,4 :: Int,semfn_0_0)
red_7 = (G_Foo,1 :: Int,semfn_0_0)
goto 0 G_Grm = 5
goto 0 G_Foo = 2

goto 1 G_Foo = 2

goto 6 G_Foo = 9

goto 7 G_Foo = 8

goto _ _ = -1
