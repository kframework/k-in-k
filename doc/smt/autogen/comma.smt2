; syntax Lst  ::= E "," Lst  [klabel(constr), symbol]
; syntax Lst2 ::= E "," Lst2 [klabel(constr), symbol]
;               | Lst
; rule I, L => L
; generated by the Dwight's z3 type inferencer

(set-logic QF_DT)

(declare-datatypes () ((Sort (|SortLst| )
(|SortCell| )
(|SortLst2| )
(|SortE| )
(|SortKItem| )
(|SortS| )
(|SortKLabel| )
(|SortK| )
(|SortBool| )
(|SortBag| )
)))
(define-fun <=Sort ((s1 Sort) (s2 Sort)) Bool (or
  (and (= s1 |SortKItem|) (= s2 |SortK|))
  (and (= s1 |SortBag|) (= s2 |SortKItem|))
  (and (= s1 |SortBag|) (= s2 |SortK|))
  (and (= s1 |SortLst2|) (= s2 |SortKItem|))
  (and (= s1 |SortLst2|) (= s2 |SortK|))
  (and (= s1 |SortLst|) (= s2 |SortKItem|))
  (and (= s1 |SortLst|) (= s2 |SortLst2|))
  (and (= s1 |SortLst|) (= s2 |SortK|))
  (and (= s1 |SortBool|) (= s2 |SortKItem|))
  (and (= s1 |SortBool|) (= s2 |SortK|))
  (and (= s1 |SortCell|) (= s2 |SortKItem|))
  (and (= s1 |SortCell|) (= s2 |SortBag|))
  (and (= s1 |SortCell|) (= s2 |SortK|))
  (and (= s1 |SortE|) (= s2 |SortKItem|))
  (and (= s1 |SortE|) (= s2 |SortK|))
  (and (= s1 |SortS|) (= s2 |SortKItem|))
  (and (= s1 |SortS|) (= s2 |SortK|))
  (and (= s1 |SortKItem|) (= s2 |SortKItem|))
  (and (= s1 |SortKLabel|) (= s2 |SortKLabel|))
  (and (= s1 |SortLst2|) (= s2 |SortLst2|))
  (and (= s1 |SortS|) (= s2 |SortS|))
  (and (= s1 |SortE|) (= s2 |SortE|))
  (and (= s1 |SortBag|) (= s2 |SortBag|))
  (and (= s1 |SortCell|) (= s2 |SortCell|))
  (and (= s1 |SortBool|) (= s2 |SortBool|))
  (and (= s1 |SortK|) (= s2 |SortK|))
  (and (= s1 |SortLst|) (= s2 |SortLst|))
))
(push)
(declare-const |FreshVarSort_1_1_1_18_#KRewrite| Sort)
(declare-const |VarI| Sort)
(declare-const |VarL| Sort)
(assert (and true (distinct |FreshVarSort_1_1_1_18_#KRewrite| |SortKLabel|) ))
(define-fun |constraint3_SortE| () Bool (and true (<=Sort |VarI| |SortE|) ))
(define-fun |constraint5_SortLst| () Bool (and true (<=Sort |VarL| |SortLst|) ))
(define-fun |constraint2_FreshVarSort_1_1_1_18_#KRewrite| () Bool (and true (<=Sort |SortLst| |FreshVarSort_1_1_1_18_#KRewrite|) |constraint3_SortE| |constraint5_SortLst| ))
(define-fun |constraint7_FreshVarSort_1_1_1_18_#KRewrite| () Bool (and true (<=Sort |VarL| |FreshVarSort_1_1_1_18_#KRewrite|) ))
(define-fun |constraint1_Sort#RuleBody| () Bool (and true (<=Sort |FreshVarSort_1_1_1_18_#KRewrite| |SortK|) |constraint2_FreshVarSort_1_1_1_18_#KRewrite| |constraint7_FreshVarSort_1_1_1_18_#KRewrite| ))
(define-fun |constraint0_Sort#RuleContent| () Bool (and true |constraint1_Sort#RuleBody| ))
(define-fun |constraint5_SortLst2| () Bool (and true (<=Sort |VarL| |SortLst2|) ))
(define-fun |constraint11_FreshVarSort_1_1_1_18_#KRewrite| () Bool (and true (<=Sort |SortLst2| |FreshVarSort_1_1_1_18_#KRewrite|) |constraint3_SortE| |constraint5_SortLst2| ))
(define-fun |constraint10_Sort#RuleBody| () Bool (and true (<=Sort |FreshVarSort_1_1_1_18_#KRewrite| |SortK|) |constraint11_FreshVarSort_1_1_1_18_#KRewrite| |constraint7_FreshVarSort_1_1_1_18_#KRewrite| ))
(define-fun |constraint9_Sort#RuleContent| () Bool (and true |constraint10_Sort#RuleBody| ))
(define-fun amb0 () Bool (or |constraint0_Sort#RuleContent| |constraint9_Sort#RuleContent| ))

(assert amb0)
(push)
(assert-soft (<=Sort SortK      |FreshVarSort_1_1_1_18_#KRewrite|) :id A)
(assert-soft (<=Sort SortKItem  |FreshVarSort_1_1_1_18_#KRewrite|) :id A)
(assert-soft (<=Sort SortBag    |FreshVarSort_1_1_1_18_#KRewrite|) :id A)
(assert-soft (<=Sort SortK      |VarI|) :id A)
(assert-soft (<=Sort SortKItem  |VarI|) :id A)
(assert-soft (<=Sort SortBag    |VarI|) :id A)
(assert-soft (<=Sort SortK      |VarL|) :id A)
(assert-soft (<=Sort SortKItem  |VarL|) :id A)
(assert-soft (<=Sort SortBag    |VarL|) :id A)
(check-sat)
(get-model)
