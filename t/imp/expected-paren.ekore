module IMP-PAREN
configuration configCell { .Sorts } ( \dv { CellName { .Sorts } } ( "T" ) , ( cellPropertyList { .Sorts } ( cellProperty { .Sorts } ( \dv { CellName { .Sorts } } ( "color" ) , ( \dv { KString { .Sorts } } ( "\"yellow\"" ) , .Patterns ) ) , ( cellPropertyListTerminator { .Sorts } ( .Patterns ) , .Patterns ) ) , cells { .Sorts } ( configCell { .Sorts } ( \dv { CellName { .Sorts } } ( "k" ) , ( cellPropertyList { .Sorts } ( cellProperty { .Sorts } ( \dv { CellName { .Sorts } } ( "color" ) , ( \dv { KString { .Sorts } } ( "\"green\"" ) , .Patterns ) ) , ( cellPropertyListTerminator { .Sorts } ( .Patterns ) , .Patterns ) ) , SemanticCastToPgm { .Sorts } ( \dv { KConfigVar { .Sorts } } ( "$PGM" ) , .Patterns ) , \dv { CellName { .Sorts } } ( "k" ) , .Patterns ) ) , ( configCell { .Sorts } ( \dv { CellName { .Sorts } } ( "state" ) , ( cellPropertyList { .Sorts } ( cellProperty { .Sorts } ( \dv { CellName { .Sorts } } ( "color" ) , ( \dv { KString { .Sorts } } ( "\"red\"" ) , .Patterns ) ) , ( cellPropertyListTerminator { .Sorts } ( .Patterns ) , .Patterns ) ) , emptyMap { .Sorts } ( .Patterns ) , \dv { CellName { .Sorts } } ( "state" ) , .Patterns ) ) , .Patterns ) ) , \dv { CellName { .Sorts } } ( "T" ) , .Patterns ) )
 import IMP-PAREN-SYNTAX [ .Patterns ]
 rule attrs ( ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( block { .Sorts } ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns ) , [ structural , .AttrList ] )
 rule attrs ( ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( emptyBlock { .Sorts } ( .Patterns ) , ( emptyK { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) , [ structural , .AttrList ] )
 rule attrs ( ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( start { .Sorts } ( emptyIds { .Sorts } ( .Patterns ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns ) , [ structural , .AttrList ] )
 rule attrs ( ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( stmts { .Sorts } ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S1" ) , .Patterns ) , ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) , .Patterns ) ) , ( kSequence { .Sorts } ( \dv { KVariable { .Sorts } } ( "S1" ) , ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) ) , .Patterns ) ) , .Patterns ) , [ structural , .AttrList ] )
 rule attrs ( ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( while { .Sorts } ( \dv { KVariable { .Sorts } } ( "B" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , ( if { .Sorts } ( \dv { KVariable { .Sorts } } ( "B" ) , ( block { .Sorts } ( stmts { .Sorts } ( \dv { KVariable { .Sorts } } ( "S" ) , ( while { .Sorts } ( \dv { KVariable { .Sorts } } ( "B" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns ) ) , .Patterns ) , emptyBlock { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) ) , .Patterns ) , [ structural , .AttrList ] )
 
 rule ruleNoConditions { .Sorts } ( 
    KRewrite { .Sorts } ( 
        and { .Sorts } ( \dv { Bool { .Sorts } } ( "false" ) , ( \dv { KVariable { .Sorts } } ( "_" ) , .Patterns ) ) , 
        ( \dv { Bool { .Sorts } } ( "false" ) , .Patterns ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( and { .Sorts } ( \dv { Bool { .Sorts } } ( "true" ) , ( \dv { KVariable { .Sorts } } ( "B" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "B" ) , .Patterns ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( if { .Sorts } ( \dv { Bool { .Sorts } } ( "false" ) , ( \dv { KVariable { .Sorts } } ( "_" ) , \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( if { .Sorts } ( \dv { Bool { .Sorts } } ( "true" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , \dv { KVariable { .Sorts } } ( "_" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( lte { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( lteInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , .Patterns ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( not { .Sorts } ( \dv { KVariable { .Sorts } } ( "T" ) , .Patterns ) , ( notBool { .Sorts } ( \dv { KVariable { .Sorts } } ( "T" ) , .Patterns ) , .Patterns ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( plus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( plusInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , .Patterns ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( uminus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) , ( minusInt { .Sorts } ( \dv { Int { .Sorts } } ( "0" ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , .Patterns ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( cells { .Sorts } ( kcell { .Sorts } ( noDots { .Sorts } ( .Patterns ) , ( KRewrite { .Sorts } ( SemanticCastToId { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , .Patterns ) , ( \dv { KVariable { .Sorts } } ( "I" ) , .Patterns ) ) , dots { .Sorts } ( .Patterns ) , .Patterns ) ) , ( statecell { .Sorts } ( dots { .Sorts } ( .Patterns ) , ( mapItem { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( \dv { KVariable { .Sorts } } ( "I" ) , .Patterns ) ) , dots { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( cells { .Sorts } ( kcell { .Sorts } ( noDots { .Sorts } ( .Patterns ) , ( KRewrite { .Sorts } ( asgn { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( SemanticCastToInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I" ) , .Patterns ) , .Patterns ) ) , ( emptyK { .Sorts } ( .Patterns ) , .Patterns ) ) , dots { .Sorts } ( .Patterns ) , .Patterns ) ) , ( statecell { .Sorts } ( dots { .Sorts } ( .Patterns ) , ( mapItem { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "_" ) , ( \dv { KVariable { .Sorts } } ( "I" ) , .Patterns ) ) , .Patterns ) ) , dots { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) ) , .Patterns )
 rule ruleRequires { .Sorts } ( KRewrite { .Sorts } ( div { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( divInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , .Patterns ) ) , ( neInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I2" ) , ( \dv { Int { .Sorts } } ( "0" ) , .Patterns ) ) , .Patterns ) )
 rule ruleRequires { .Sorts } ( cells { .Sorts } ( kcell { .Sorts } ( noDots { .Sorts } ( .Patterns ) , ( start { .Sorts } ( KRewrite { .Sorts } ( consIds { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( \dv { KVariable { .Sorts } } ( "Xs" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "Xs" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "_" ) , .Patterns ) ) , noDots { .Sorts } ( .Patterns ) , .Patterns ) ) , ( statecell { .Sorts } ( noDots { .Sorts } ( .Patterns ) , ( mapConcat { .Sorts } ( SemanticCastToMap { .Sorts } ( \dv { KVariable { .Sorts } } ( "Rho" ) , .Patterns ) , ( KRewrite { .Sorts } ( emptyMap { .Sorts } ( .Patterns ) , ( mapItem { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( \dv { Int { .Sorts } } ( "0" ) , .Patterns ) ) , .Patterns ) ) , .Patterns ) ) , noDots { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) ) , ( notBool { .Sorts } ( keyInSet { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( keysOfMap { .Sorts } ( \dv { KVariable { .Sorts } } ( "Rho" ) , .Patterns ) , .Patterns ) ) , .Patterns ) , .Patterns ) )
 syntax Id ::= "n" [ token , .AttrList ]
 syntax Id ::= "sum" [ token , .AttrList ]
 syntax KResult ::= Bool noAtt
 syntax KResult ::= Int noAtt

endmodule
