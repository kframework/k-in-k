module IMP
configuration configCell { .Sorts } ( \dv { CellName { .Sorts } } ( "T" ) , ( cellPropertyList { .Sorts } ( cellProperty { .Sorts } ( \dv { CellName { .Sorts } } ( "color" ) , ( \dv { KString { .Sorts } } ( "\"yellow\"" ) , .Patterns ) ) , ( cellPropertyListTerminator { .Sorts } ( .Patterns ) , .Patterns ) ) , cells { .Sorts } ( configCell { .Sorts } ( \dv { CellName { .Sorts } } ( "k" ) , ( cellPropertyList { .Sorts } ( cellProperty { .Sorts } ( \dv { CellName { .Sorts } } ( "color" ) , ( \dv { KString { .Sorts } } ( "\"green\"" ) , .Patterns ) ) , ( cellPropertyListTerminator { .Sorts } ( .Patterns ) , .Patterns ) ) , SemanticCastToPgm { .Sorts } ( \dv { KConfigVar { .Sorts } } ( "$PGM" ) , .Patterns ) , \dv { CellName { .Sorts } } ( "k" ) , .Patterns ) ) , ( configCell { .Sorts } ( \dv { CellName { .Sorts } } ( "state" ) , ( cellPropertyList { .Sorts } ( cellProperty { .Sorts } ( \dv { CellName { .Sorts } } ( "color" ) , ( \dv { KString { .Sorts } } ( "\"red\"" ) , .Patterns ) ) , ( cellPropertyListTerminator { .Sorts } ( .Patterns ) , .Patterns ) ) , emptyMap { .Sorts } ( .Patterns ) , \dv { CellName { .Sorts } } ( "state" ) , .Patterns ) ) , .Patterns ) ) , \dv { CellName { .Sorts } } ( "T" ) , .Patterns ) )
 import IMP-SYNTAX [ .Patterns ]
 rule attrs ( ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( block { .Sorts } ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns ) , [ structural , .AttrList ] )
 rule attrs ( ruleNoConditions { .Sorts } ( KRewrite { .Sorts } ( emptyBlock { .Sorts } ( .Patterns ) , ( emptyK { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) , [ structural , .AttrList ] )
 rule attrs ( ruleNoConditions { .Sorts } ( \or { KBott { .Sorts } } ( KRewrite { .Sorts } ( start { .Sorts } ( emptyIds { .Sorts } ( .Patterns ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , \or { KBott { .Sorts } } ( start { .Sorts } ( emptyIds { .Sorts } ( .Patterns ) , ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "S" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns ) ) , \bottom { KBott { .Sorts } } ( ) ) ) , .Patterns ) , [ structural , .AttrList ] )
 rule attrs ( ruleNoConditions { .Sorts } ( \or { KBott { .Sorts } } ( kSequence { .Sorts } ( \or { Stmt { .Sorts } } ( stmts { .Sorts } ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S1" ) , .Patterns ) , ( KRewrite { .Sorts } ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) , ( \dv { KVariable { .Sorts } } ( "S1" ) , .Patterns ) ) , .Patterns ) ) , \or { Stmt { .Sorts } } ( KRewrite { .Sorts } ( \or { Stmt { .Sorts } } ( SemanticCastToStmt { .Sorts } ( stmts { .Sorts } ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S1" ) , .Patterns ) , ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) ) , .Patterns ) , \or { Stmt { .Sorts } } ( stmts { .Sorts } ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S1" ) , .Patterns ) , ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) , .Patterns ) ) , \bottom { Stmt { .Sorts } } ( ) ) ) , ( \dv { KVariable { .Sorts } } ( "S1" ) , .Patterns ) ) , \bottom { Stmt { .Sorts } } ( ) ) ) , ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) ) , \or { KBott { .Sorts } } ( KRewrite { .Sorts } ( \or { Stmt { .Sorts } } ( SemanticCastToStmt { .Sorts } ( stmts { .Sorts } ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S1" ) , .Patterns ) , ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) ) , .Patterns ) , \or { Stmt { .Sorts } } ( stmts { .Sorts } ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S1" ) , .Patterns ) , ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) , .Patterns ) ) , \bottom { Stmt { .Sorts } } ( ) ) ) , ( kSequence { .Sorts } ( \dv { KVariable { .Sorts } } ( "S1" ) , ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) ) , .Patterns ) ) , \or { KBott { .Sorts } } ( stmts { .Sorts } ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S1" ) , .Patterns ) , ( \or { KBott { .Sorts } } ( kSequence { .Sorts } ( KRewrite { .Sorts } ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) , ( \dv { KVariable { .Sorts } } ( "S1" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) ) , \or { KBott { .Sorts } } ( KRewrite { .Sorts } ( SemanticCastToStmt { .Sorts } ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) , ( kSequence { .Sorts } ( \dv { KVariable { .Sorts } } ( "S1" ) , ( \dv { KVariable { .Sorts } } ( "S2" ) , .Patterns ) ) , .Patterns ) ) , \bottom { KBott { .Sorts } } ( ) ) ) , .Patterns ) ) , \bottom { KBott { .Sorts } } ( ) ) ) ) , .Patterns ) , [ structural , .AttrList ] )
 rule attrs ( ruleNoConditions { .Sorts } ( \or { Stmt { .Sorts } } ( while { .Sorts } ( \dv { KVariable { .Sorts } } ( "B" ) , ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "S" ) , ( if { .Sorts } ( \dv { KVariable { .Sorts } } ( "B" ) , ( block { .Sorts } ( stmts { .Sorts } ( \dv { KVariable { .Sorts } } ( "S" ) , ( while { .Sorts } ( \dv { KVariable { .Sorts } } ( "B" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns ) ) , .Patterns ) , emptyBlock { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) ) , .Patterns ) ) , \or { Stmt { .Sorts } } ( KRewrite { .Sorts } ( while { .Sorts } ( \dv { KVariable { .Sorts } } ( "B" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , ( if { .Sorts } ( \dv { KVariable { .Sorts } } ( "B" ) , ( block { .Sorts } ( stmts { .Sorts } ( \dv { KVariable { .Sorts } } ( "S" ) , ( while { .Sorts } ( \dv { KVariable { .Sorts } } ( "B" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns ) ) , .Patterns ) , emptyBlock { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) ) , \bottom { Stmt { .Sorts } } ( ) ) ) , .Patterns ) , [ structural , .AttrList ] )
 rule ruleNoConditions { .Sorts } ( \or { AExp { .Sorts } } ( uminus { .Sorts } ( \or { Int { .Sorts } } ( minusInt { .Sorts } ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { Int { .Sorts } } ( "0" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , \or { Int { .Sorts } } ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( minusInt { .Sorts } ( \dv { Int { .Sorts } } ( "0" ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , .Patterns ) ) , \bottom { Int { .Sorts } } ( ) ) ) , .Patterns ) , \or { AExp { .Sorts } } ( minusInt { .Sorts } ( KRewrite { .Sorts } ( uminus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) , ( \dv { Int { .Sorts } } ( "0" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , \or { AExp { .Sorts } } ( KRewrite { .Sorts } ( uminus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) , ( minusInt { .Sorts } ( \dv { Int { .Sorts } } ( "0" ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , .Patterns ) ) , \bottom { AExp { .Sorts } } ( ) ) ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( 
  \or { BExp { .Sorts } } ( 
      and { .Sorts } ( 
          \dv { Bool { .Sorts } } ( "false" ) , 
          ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "_" ) , ( \dv { Bool { .Sorts } } ( "false" ) , .Patterns ) ) , .Patterns ) ) , 
  \or { BExp { .Sorts } } ( 
      KRewrite { .Sorts } ( 
          and { .Sorts } ( \dv { Bool { .Sorts } } ( "false" ) , ( \dv { KVariable { .Sorts } } ( "_" ) , .Patterns ) ) , 
          ( \dv { Bool { .Sorts } } ( "false" ) , .Patterns ) ) , \bottom { BExp { .Sorts } } ( ) ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( \or { BExp { .Sorts } } ( and { .Sorts } ( \dv { Bool { .Sorts } } ( "true" ) , ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "B" ) , ( \dv { KVariable { .Sorts } } ( "B" ) , .Patterns ) ) , .Patterns ) ) , \or { BExp { .Sorts } } ( KRewrite { .Sorts } ( and { .Sorts } ( \dv { Bool { .Sorts } } ( "true" ) , ( \dv { KVariable { .Sorts } } ( "B" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "B" ) , .Patterns ) ) , \bottom { BExp { .Sorts } } ( ) ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( \or { BExp { .Sorts } } ( not { .Sorts } ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "T" ) , ( notBool { .Sorts } ( \dv { KVariable { .Sorts } } ( "T" ) , .Patterns ) , .Patterns ) ) , .Patterns ) , \or { BExp { .Sorts } } ( KRewrite { .Sorts } ( not { .Sorts } ( \dv { KVariable { .Sorts } } ( "T" ) , .Patterns ) , ( notBool { .Sorts } ( \dv { KVariable { .Sorts } } ( "T" ) , .Patterns ) , .Patterns ) ) , \bottom { BExp { .Sorts } } ( ) ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( \or { Bag { .Sorts } } ( cells { .Sorts } ( KRewrite { .Sorts } ( lte { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( lte { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "Int" ) , .Patterns ) ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Bag { .Sorts } } ( lteInt { .Sorts } ( KRewrite { .Sorts } ( lte { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Bag { .Sorts } } ( lte { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \or { Int { .Sorts } } ( lteInt { .Sorts } ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "I2" ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Int { .Sorts } } ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "I2" ) , ( lteInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , .Patterns ) ) , \bottom { Int { .Sorts } } ( ) ) ) , .Patterns ) ) , \or { Bag { .Sorts } } ( KRewrite { .Sorts } ( lte { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( lteInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , .Patterns ) ) , \or { Bag { .Sorts } } ( mapConcat { .Sorts } ( KRewrite { .Sorts } ( lte { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( lte { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "Int" ) , .Patterns ) ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Bag { .Sorts } } ( stmts { .Sorts } ( KRewrite { .Sorts } ( lte { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( lte { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "Int" ) , .Patterns ) ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \bottom { Bag { .Sorts } } ( ) ) ) ) ) ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( \or { Bag { .Sorts } } ( cells { .Sorts } ( KRewrite { .Sorts } ( plus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( plus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "Int" ) , .Patterns ) ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Bag { .Sorts } } ( plusInt { .Sorts } ( KRewrite { .Sorts } ( plus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Bag { .Sorts } } ( KRewrite { .Sorts } ( plus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( plusInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , .Patterns ) ) , \or { Bag { .Sorts } } ( mapConcat { .Sorts } ( KRewrite { .Sorts } ( plus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( plus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "Int" ) , .Patterns ) ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Bag { .Sorts } } ( plus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \or { Int { .Sorts } } ( plusInt { .Sorts } ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "I2" ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Int { .Sorts } } ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "I2" ) , ( plusInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , .Patterns ) ) , \bottom { Int { .Sorts } } ( ) ) ) , .Patterns ) ) , \or { Bag { .Sorts } } ( stmts { .Sorts } ( KRewrite { .Sorts } ( plus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( plus { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "Int" ) , .Patterns ) ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \bottom { Bag { .Sorts } } ( ) ) ) ) ) ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( \or { KBott { .Sorts } } ( KRewrite { .Sorts } ( if { .Sorts } ( \dv { Bool { .Sorts } } ( "false" ) , ( \dv { KVariable { .Sorts } } ( "_" ) , \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , \or { KBott { .Sorts } } ( if { .Sorts } ( \dv { Bool { .Sorts } } ( "false" ) , ( \dv { KVariable { .Sorts } } ( "_" ) , KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "S" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns ) ) , \bottom { KBott { .Sorts } } ( ) ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( \or { KBott { .Sorts } } ( KRewrite { .Sorts } ( if { .Sorts } ( \dv { Bool { .Sorts } } ( "true" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , \dv { KVariable { .Sorts } } ( "_" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , \or { KBott { .Sorts } } ( if { .Sorts } ( \dv { Bool { .Sorts } } ( "true" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "_" ) , ( \dv { KVariable { .Sorts } } ( "S" ) , .Patterns ) ) , .Patterns ) ) , \bottom { KBott { .Sorts } } ( ) ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( cells { .Sorts } ( kcell { .Sorts } ( noDots { .Sorts } ( .Patterns ) , ( KRewrite { .Sorts } ( SemanticCastToId { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , .Patterns ) , ( \dv { KVariable { .Sorts } } ( "I" ) , .Patterns ) ) , dots { .Sorts } ( .Patterns ) , .Patterns ) ) , ( statecell { .Sorts } ( dots { .Sorts } ( .Patterns ) , ( mapItem { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( \dv { KVariable { .Sorts } } ( "I" ) , .Patterns ) ) , dots { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) ) , .Patterns )
 rule ruleNoConditions { .Sorts } ( cells { .Sorts } ( kcell { .Sorts } ( noDots { .Sorts } ( .Patterns ) , ( KRewrite { .Sorts } ( asgn { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( SemanticCastToInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I" ) , .Patterns ) , .Patterns ) ) , ( emptyK { .Sorts } ( .Patterns ) , .Patterns ) ) , dots { .Sorts } ( .Patterns ) , .Patterns ) ) , ( statecell { .Sorts } ( dots { .Sorts } ( .Patterns ) , ( mapItem { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "_" ) , ( \dv { KVariable { .Sorts } } ( "I" ) , .Patterns ) ) , .Patterns ) ) , dots { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) ) , .Patterns )
 rule ruleRequires { .Sorts } ( \or { Bag { .Sorts } } ( cells { .Sorts } ( KRewrite { .Sorts } ( div { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( div { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "Int" ) , .Patterns ) ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Bag { .Sorts } } ( div { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \or { KBott { .Sorts } } ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "I2" ) , ( divInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , .Patterns ) ) , \or { KBott { .Sorts } } ( divInt { .Sorts } ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "I2" ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \bottom { KBott { .Sorts } } ( ) ) ) , .Patterns ) ) , \or { Bag { .Sorts } } ( KRewrite { .Sorts } ( div { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( divInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , .Patterns ) ) , \or { Bag { .Sorts } } ( mapConcat { .Sorts } ( KRewrite { .Sorts } ( div { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( div { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "Int" ) , .Patterns ) ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Bag { .Sorts } } ( divInt { .Sorts } ( KRewrite { .Sorts } ( div { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I1" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \or { Bag { .Sorts } } ( stmts { .Sorts } ( KRewrite { .Sorts } ( div { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , ( div { .Sorts } ( \dv { KVariable { .Sorts } } ( "I1" ) , ( \dv { KVariable { .Sorts } } ( "Int" ) , .Patterns ) ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "I2" ) , .Patterns ) ) , \bottom { Bag { .Sorts } } ( ) ) ) ) ) ) ) , ( neInt { .Sorts } ( \dv { KVariable { .Sorts } } ( "I2" ) , ( \dv { Int { .Sorts } } ( "0" ) , .Patterns ) ) , .Patterns ) )
 rule ruleRequires { .Sorts } ( cells { .Sorts } ( kcell { .Sorts } ( noDots { .Sorts } ( .Patterns ) , ( start { .Sorts } ( \or { Ids { .Sorts } } ( consIds { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( KRewrite { .Sorts } ( \dv { KVariable { .Sorts } } ( "Xs" ) , ( \dv { KVariable { .Sorts } } ( "Xs" ) , .Patterns ) ) , .Patterns ) ) , \or { Ids { .Sorts } } ( KRewrite { .Sorts } ( consIds { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( \dv { KVariable { .Sorts } } ( "Xs" ) , .Patterns ) ) , ( \dv { KVariable { .Sorts } } ( "Xs" ) , .Patterns ) ) , \bottom { Ids { .Sorts } } ( ) ) ) , ( \dv { KVariable { .Sorts } } ( "_" ) , .Patterns ) ) , noDots { .Sorts } ( .Patterns ) , .Patterns ) ) , ( statecell { .Sorts } ( noDots { .Sorts } ( .Patterns ) , ( mapConcat { .Sorts } ( SemanticCastToMap { .Sorts } ( \dv { KVariable { .Sorts } } ( "Rho" ) , .Patterns ) , ( \or { Map { .Sorts } } ( mapItem { .Sorts } ( KRewrite { .Sorts } ( emptyMap { .Sorts } ( .Patterns ) , ( \dv { KVariable { .Sorts } } ( "X" ) , .Patterns ) ) , ( \dv { Int { .Sorts } } ( "0" ) , .Patterns ) ) , \or { Map { .Sorts } } ( KRewrite { .Sorts } ( emptyMap { .Sorts } ( .Patterns ) , ( mapItem { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( \dv { Int { .Sorts } } ( "0" ) , .Patterns ) ) , .Patterns ) ) , \bottom { Map { .Sorts } } ( ) ) ) , .Patterns ) ) , noDots { .Sorts } ( .Patterns ) , .Patterns ) ) , .Patterns ) ) , ( notBool { .Sorts } ( keyInSet { .Sorts } ( \dv { KVariable { .Sorts } } ( "X" ) , ( keysOfMap { .Sorts } ( \dv { KVariable { .Sorts } } ( "Rho" ) , .Patterns ) , .Patterns ) ) , .Patterns ) , .Patterns ) )
 syntax Id ::= "n" [ token , .AttrList ]
 syntax Id ::= "sum" [ token , .AttrList ]
 syntax KResult ::= Bool noAtt
 syntax KResult ::= Int noAtt

endmodule 
     